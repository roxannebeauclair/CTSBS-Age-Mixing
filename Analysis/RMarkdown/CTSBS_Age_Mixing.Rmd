---
title: "CTSBS Age-Mixing"
author: "Roxanne Beauclair"
date: '`r format(Sys.Date(), "%d %b %Y")`'
output: html_document
---

```{r setup, include = FALSE}
# ===================
# Relative file paths
# ===================
wd <- "/Users/roxannebeauclair/Documents/Analytical Projects/PhD/CTSbS Age Mixing/Analysis"
cdata <- paste0(wd, "/Data/Cleaned")

concurdata <- paste0(cdata, "/ctsbs_concur_added_data.rda")
imputedata <- paste0(cdata, "/ctsbs_impute_data.rda")
imputedatapart <- paste0(cdata, "/ctsbs_impute_data_part.rda")
bootdata <- paste0(cdata, "/ctsbs_boot_amp_data.rda")
groupdata <- paste0(cdata, "/ctsbs_group_data.rda")


fxn <- paste0(wd, "/Scripts/00-Functions.R")

# ====================
# Loading dependencies
# ====================
source(fxn)

# magrittr: for use of %>% operator
# tidyverse: for data management functions
# mice: for MI


InstallLoad("magrittr", "MASS", "tidyverse", 
            "mice","nlme", "lme4", "modelr",
            "mgcv", "gamm4", "broom", "splines", 
            "mediation", "forcats", "Gmisc", "htmlTable")

# =============
# Load datasets
# =============
load(imputedata)
load(imputedatapart)
load(concurdata)
load(bootdata)
load(groupdata)

# ====================
# Set specific global options
# ====================

# Set theme for plots
theme <- theme(axis.title.x = element_text(face = "bold", size = 10),
             axis.text.x  = element_text(angle = 0, face = "bold",
                                         colour = "black", size = 8),
             axis.title.y = element_text(face = "bold", size = 10),
             axis.text.y = element_text(angle = 0, 
                                        face = "bold", 
                                        colour = "black", 
                                        hjust = 0.5,
                                        size = 8),
             plot.title = element_text(lineheight = .8, face = "bold"),
             panel.grid.major = element_line(colour = 'grey82'),
             panel.grid.minor = element_line(colour = NA),
             panel.background = element_rect(fill = 'white'),
             strip.background = element_rect(fill = 'white'),
             strip.text = element_text(size = 8, face = "bold"),
             legend.title = element_text(colour = "black", size = 9, face = "bold"),
             legend.text = element_text(size = 8, face = "bold"),
             plot.margin = unit(c(1.5,1,1,1), "lines"))


# Initialize table counter
options(show.signif.stars = F)
```


```{r df_description, include = FALSE}
# How many exclusions due to sexuality
df1 <- df %>%
  filter(sexorientation != "both" | is.na(sexorientation)) %>%
  filter((sex == "Male" & sexorientation == "Women") |
           ((sex == "Female" & sexorientation == "Men")) |
              (is.na(sex))) 

n_sexuality <- nrow(df) - nrow(df1)

# How many exclusions due to race
df2 <- df1 %>%
  filter(race == "Coloured" | 
           race == "Black" |
           is.na(race)) 

n_race <- nrow(df1) - nrow(df2)

# How many exclusions due to no parter reported
df3 <- df2 %>%
  filter(partner != 0) 

n_nopart <- nrow(df2) - nrow(df3)

# How many relationships left
rels_left <- nrow(df3)

# How many participants left
parts_left <- df3 %>%
  distinct(id) %>%
  nrow()

imp <- max(as.integer(dfimp$.imp)) - 1

# How many relationships started in the last year
df4 <- df3 %>%
  mutate(start = as.factor(ifelse(!is.na(start), "Last year", "before last year"))) %>%
  filter(start == "Last year")

rels_last_year <- nrow(df4)

# How many participants had more than 1 relationship
df5 <- partdfimp %>%
  filter(.imp == 23) %>%
  filter(relcount > 1)

parts_many_partner <- nrow(df5)

rm(df, df1, df2, df3, df4, df5)

```

<br>

**Research questions:** 

1. Describe the age-mixing pattern in the CTSBS population. Does the age-mixing pattern of HIV positive participants differ from HIV negative participants?
2. At the individual-level are large ranges in partner ages (bridgewidths) associated with HIV status of a participant?

Before conducting imputations, I excluded participants who said their sexual preferences were for "both" genders or the same gender (n = `r n_sexuality`). I further excluded people who did not identify as black or coloured (n = `r n_race`) and people who did not report partners in the previous year (n = `r n_nopart`). Participants who had missing observations on those characteristics were left in the dataset. This left `r rels_left` relationships reported by `r parts_left` participants. Of the `r parts_left` participants, `r parts_many_partner` reported more than one relationship in the previous year. I imputed `r imp` datasets using the random forest method for continuous and nominal categorical variables and the "polr" method for our ordinal variables. 

```{r amp_setup, include = FALSE}

# What is the age mixing pattern?
set.seed(4762)
n <- sample(1:imp, 1)

# Smaller datasets
dfamp <- dfimp %>%
  filter(.imp == n) %>%
  select(id, age, age0, agep, sex,
         missage, missagep, hiv) 

# HIV negative
dfampm <- dfamp %>%
  filter(sex == "Male" & hiv == "Negative")

dfampw <- dfamp %>%
  filter(sex == "Female" & hiv == "Negative")


# Now fit separate models for HIC neg men and women
# Separate models with and without explicit power var structure
ampmodm <- lme(agep ~ age0, 
           data = dfampm, 
           random = ~1 | id,
           weights = varPower(value = 0.5, form = ~age0 + 1),
           method = "REML")

ampmodw <- lme(agep ~ age0, 
           data = dfampw, 
           random = ~1 | id,
           weights = varPower(value = 0.5, form = ~age0 + 1),
           method = "REML")

ampmodm2 <- lme(agep ~ age0, 
           data = dfampm, 
           random = ~1 | id,
           method = "REML")

ampmodw2 <- lme(agep ~ age0, 
           data = dfampw, 
           random = ~1 | id,
           method = "REML")

# Compare fit of male negative models with and without 
# power variance structure
bicampmodm1 <- BIC(ampmodm)
bicampmodm2 <- BIC(ampmodm2)

bicampmodm1
bicampmodm2

# Compare female negative models
bicampmodw1 <- BIC(ampmodw)
bicampmodw2 <- BIC(ampmodw2)

bicampmodw1
bicampmodw2


# Add the predicted values and residuals to the dataset
# In both neg men and women there should be power var structure
dfampm <- dfampm %>%
  mutate(pred = predict(ampmodm, newdata = ., level = 0)) %>%
  add_residuals(ampmodm, var = "resid")

dfampw <- dfampw %>%
  mutate(pred = predict(ampmodw, newdata = ., level = 0)) %>%
  add_residuals(ampmodw, var = "resid") 

#Combine both datasets again
comb <- bind_rows(dfampm, dfampw)

# For only those with HIV
# Separate models with and without explicit power var structure

dfamphiv <- dfimp %>%
  filter(.imp == n) %>%
  select(id, age, age0, agep, sex,
         missage, missagep, hiv)

dfamphivm <- dfamphiv %>%
  filter(sex == "Male" & hiv == "Positive")

dfamphivw <- dfamphiv %>%
  filter(sex == "Female" & hiv == "Positive")


# Now fit separate models for men and women
amphivmodm <- lme(agep ~ age0, 
           data = dfamphivm, 
           random = ~1 | id,
           weights = varPower(value = 0.5, form = ~age0 + 1),
           method = "REML")

amphivmodw <- lme(agep ~ age0, 
           data = dfamphivw, 
           random = ~1 | id,
           weights = varPower(value = 0.5, form = ~age0 + 1),
           method = "REML")

amphivmodm2 <- lme(agep ~ age0, 
           data = dfamphivm, 
           random = ~1 | id,
           method = "REML")

amphivmodw2 <- lme(agep ~ age0, 
           data = dfamphivw, 
           random = ~1 | id,
           method = "REML")

# Compare fit of male positive models with and without 
# power variance structure
bicamphivmodm1 <- BIC(amphivmodm)
bicamphivmodm2 <- BIC(amphivmodm2)

bicamphivmodm1
bicamphivmodm2

# Compare female positive models
bicamphivmodw1 <- BIC(amphivmodw)
bicamphivmodw2 <- BIC(amphivmodw2)

bicamphivmodw1
bicamphivmodw2

# Add the predicted values to the dataset
dfamphivm <- dfamphivm %>%
  mutate(pred = predict(amphivmodm, newdata = ., level = 0))%>%
  add_residuals(amphivmodm, var = "resid")

dfamphivw <- dfamphivw %>%
  mutate(pred = predict(amphivmodw2, newdata = ., level = 0)) %>% # Model without var struct
  add_residuals(amphivmodw2, var = "resid")

#Combine both male and female HIV datasets again
comb2 <- bind_rows(dfamphivm, dfamphivw) 

# Now add the HIV dataset to the negative dataset
comb_all <- bind_rows(comb, comb2)
  
```

<br>

### **AGE-MIXING PATTERN**

<br>

Here I used linear mixed effects models that were stratified by sex and contained a random intercept for the participant. For the plots, I randomly selected an imputed dataset to visualize the pattern in that population. Heteroskedastic variance is now taken into account in the models that produced these predictions.

<br>

###### **Figure 1. Age mixing pattern for randomly selected imputed dataset. The top row represents the male and female age mixing patterns HIV negative study population, while the bottom row is for only those with HIV**

<br>

```{r amp_fig, echo = FALSE, warning = FALSE}
# Figure visualizing the age mixing pattern
ampfig <- comb_all %>%
  ggplot(aes(x = age, y = pred)) +
  geom_point(aes(x = age, 
                 y = agep, 
                 color = missagep), 
             position = position_jitter(width = 0.75, height = 0.75),
             size = 1) +
  geom_abline(size = 1, 
              aes(intercept = 0, slope = 1, linetype = "Same age"), 
              show.legend = FALSE) +
  geom_line(aes(linetype = "Population mean"), 
            size = 1) +
  facet_grid(hiv ~ sex) + 
  scale_y_continuous(name = "Partner's ages") +
  scale_color_manual('Imputation Status', values = c('grey70', 'grey42')) +
  scale_linetype_manual('Lines', values = c("Population mean" = 1, 'Same age' = 2)) +
  xlab("Participant's age") +
  guides(linetype = guide_legend(keywidth = 2, keyheight = 1)) +
  theme

ampfig

```


```{r amp_res_fig, include = FALSE, warning = FALSE}
# Visualizing spread of residuals for lm 
ampresfig1 <- comb_all %>%
  ggplot(aes(resid)) +
  geom_freqpoly(binwidth = 0.5) +
  facet_grid(hiv ~ sex) +
  theme

ampresfig1

# Visualizing pattern of residuals for lm 
ampresfig2 <- comb_all %>%
  ggplot(aes(x = age, y = resid)) +
  geom_point() +
  geom_smooth(method = "loess") +
  geom_ref_line(h = 0) +
  facet_grid(hiv ~ sex) + 
  theme

ampresfig2

```

```{r slope_int_setup, include = FALSE, warning = FALSE}
# Unnest tidy summary for (lme) data on slope and intercept
# of all the models
modslopeint <- tidysumamp %>%
  unnest(modelsum, .drop = TRUE)

# Calculate difference between estimate, 
# then fraction of differences
slopeintdif <- modslopeint %>%
  select(-std.error, -statistic, -p.value) %>%
  unite(subpop, sex, hiv) %>%
  spread(subpop, estimate) 

# Fraction of imputed dfs where differenes between 
# slopes are <= 0. 
gendifslopesum <- slopeintdif %>%
  filter(term == "age0") %>%
  mutate(gendifneg = Female_Negative - Male_Negative, # Ha: Female slopes larger than males
         gendifnegind = as.factor(ifelse(gendifneg <= 0, "Null", "Diff"))) %>%
  group_by(gendifnegind) %>%
  summarize(n = n()) %>%
  mutate(prop = round(n / sum(n), 2))

# All slopes are different between genders among HIV negative people
gendifslopeprop <- 0.00

```

```{r wvar_setup, include = FALSE, warning = FALSE}

# Unnest tidy summary for (lme) data on within individual variance
modwvar <- tidysumamp %>%
  unnest(wvar, .drop = TRUE)

```

```{r bvar_setup, include = FALSE, warning = FALSE}

# Uneest tidy summary for (lme) data on between individual variance
modbvar <- tidysumamp %>%
  unnest(bvar, .drop = TRUE)

```

```{r power_setup, include = FALSE, warning = FALSE}

# Unnest tidy summary for (lme) data on power coefficient
modpower <- tidysumamp %>%
  unnest(power, .drop = TRUE)

```

<br>

###### **Figure 2. Extractions of model slopes, intercepts, intercept variance and residual variance for each imputed dataset. The top row represents the male and female age mixing patterns in the whole study population, while the bottom row is for only those with HIV**

<br>

```{r amp_model_slope_plot, echo = FALSE, warning = FALSE, fig.height = 8}

# Plot all of the beta's for age mixing pattern in 
# each of the 100 datasets (by imputation and gender)
slopeplot <- modslopeint %>%
  filter(term == "age0") %>%
  ggplot(aes(x = .imp, y = estimate)) +
  geom_point() +
  geom_pointrange(aes(ymax = estimate + 2 * std.error,
                      ymin = estimate - 2 * std.error)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  xlab("Imputation") +
  ylab("Slope of regression line (nlme)") +
  theme

slopeplot
```

<br>


```{r amp_model_intercept_plot, echo = FALSE, warning = FALSE, fig.height = 8}
# Plot all of the intercepts for age mixing pattern in 
# each of the 100 datasets (by imputation and gender)
interplot <- modslopeint %>%
  filter(term == "(Intercept)") %>%
  ggplot(aes(.imp, estimate)) +
  geom_point() +
  geom_pointrange(aes(ymax = estimate + 2 * std.error,
                      ymin = estimate - 2 * std.error)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  xlab("Imputation") +
  ylab("Partner age for 15 year olds (nlme)") +
  theme

interplot
```

<br>

```{r amp_model_wvar_plot, echo = FALSE, warning = FALSE, fig.height = 8}
# Plot each of the residual variances for age mixing pattern
# in each of the 100 datasets (by imputation and gender)
wvarplot <- modwvar %>%
  ggplot(aes(.imp, wsd)) +
  geom_point() +
  geom_pointrange(aes(ymax = uprwsd,
                      ymin = lwrwsd)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  xlab("Imputation") +
  ylab("Within-Subject SD (nlme)") +
  theme

wvarplot
```

<br>


```{r amp_model_bvar_plot, echo = FALSE, warning = FALSE, fig.height = 8}
# Plot each of the between subject variances for age mixing pattern
# in each of the 100 datasets (by imputation and gender)
bvarplot <- modbvar %>%
  ggplot(aes(.imp, bsd)) +
  geom_point() +
  geom_pointrange(aes(ymax = uprbsd,
                      ymin = lwrbsd)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  scale_y_continuous(limits = c(0, 20)) +
  xlab("Imputation") +
  ylab("between-Subject SD (nlme)") +
  theme

bvarplot
```

<br>


```{r amp_model_power_plot, echo = FALSE, warning = FALSE, fig.height = 8}

# The formula to calculate the weights for variance is |v|^(2*t)
# I belive t is the power coefficient

powplot <- modpower %>%
  filter(sex == "Male" | hiv == "Negative") %>%
  ggplot(aes(.imp, power)) +
  geom_point() +
  geom_pointrange(aes(ymax = uprpow,
                      ymin = lwrpow)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  #scale_y_continuous(limits = c(0, 20)) +
  xlab("Imputation") +
  ylab("Power variance function coefficient (nlme)") +
  theme

powplot
```


```{r age_hiv_fig, include = FALSE, warning = FALSE, fig.height = 8}
# Create dataframe that summarizes the proportion of relationships
# in different partner age groups for people who are HIV
# positive
hivbyage <- impsexhivamp %>%
  unnest() %>%
  ungroup() %>%
  filter(.imp == n & hiv == "Positive") %>%
  group_by(sex, agepgroup) %>%
  summarise(n = n()) %>%
  mutate(prop = round((n / sum(n)) * 100, 2))

# barplot of fraction of relationships in different partner age groups  
hivageplot <- hivbyage %>%
  ggplot(aes(x = agepgroup, y = prop, fill = sex)) +
  geom_bar(stat = "identity",
           position = position_dodge()) +
  xlab("Age group of partner") +
  ylab("Proportion of relationships") +
  scale_fill_brewer(palette = "Dark2") +
  theme

hivageplot
  
```

<br>

### **REPORTING MORE THAN ONE PARTNER**

<br>

```{r multiple partners_setup, include = FALSE, warning = FALSE}
dfmpm <- partdfimp %>% 
  filter(.imp == n & 
           sex == "Male") %>%
  mutate(mp = as.factor(ifelse(relcount > 1, "Multiple", "One"))) 

dfmpw <- partdfimp %>%
  filter(.imp == n & 
           sex == "Female") %>%
  mutate(mp = as.factor(ifelse(relcount > 1, "Multiple", "One"))) 

agem <- GetT1Stat(dfmpm$agegroup, dfmpm$mp)
agew <- GetT1Stat(dfmpw$agegroup, dfmpw$mp)

hivm <- GetT1Stat(dfmpm$hiv, dfmpm$mp)
hivw <- GetT1Stat(dfmpw$hiv, dfmpw$mp)


tab1 <- list()

tab1[["Age"]] <- cbind(agew, agem)
tab1[["HIV status"]] <- cbind(hivm, hivw)
```

```{r multiple_partners_table, echo = FALSE, warning = FALSE}
mergeDesc(tab1) %>%
  htmlTable(caption = "<b>Table 1. Proportion of participants reporting more than 1 partner<b/>",
            tfoot = "Categories are reported in percentages, n (%).",
            cgroup = c("Women", "Men"), 
            n.cgroup = c(2, 2), 
            ctable = TRUE,
            padding.rgroup = "&nbsp; &nbsp; &nbsp;")

```

<br>

### **DO BRIDGEWIDTHS GROW WITH AGE?**

```{r bw_age_sd_setup, include = FALSE}
bwdfm <- partdfimp %>%
  filter(.imp == n) %>%
  filter(sex == "Male" &
           relcount > 1) %>%
  select(agegroup, bridgewidth) %>%
  group_by(agegroup) %>%
  summarise(n = n(),
            Median = median(bridgewidth),
            Q25 = summary(bridgewidth)[[2]],
            Q75 = summary(bridgewidth)[[5]]) %>%
  data.frame(row.names = 1) %>%
  format(nsmall = 1)
  

bwdfw <- partdfimp %>%
  filter(.imp == n) %>%
  filter(sex == "Female" &
           relcount > 1) %>%
  select(agegroup, bridgewidth) %>%
  group_by(agegroup) %>%
  summarise(n = n(),
            Median = median(bridgewidth),
            Q25 = summary(bridgewidth)[[2]],
            Q75 = summary(bridgewidth)[[5]]) %>%
  data.frame(row.names = 1) %>%
  format(nsmall = 1)
  
```

```{r bw_age_sd_table, echo = FALSE}

htmlTable(cbind(bwdfm, bwdfw),
          caption = "<b>Table 1. Median and IQR for bridgewidth by age and gender in randomly selected imputed dataset<b/>",
          ctable = TRUE,
          tfoot = txtMergeLines("IQR, Inter-quartile range",
                                "Q25, Lower quartile",
                                "Q75, Upper quartile"),
          cgroup = c("Male", "Female"),
          n.cgroup = c(4,4),
          rowlabel = "Age category")

```


<br>

### **DOES HIV STATUS PREDICT BRIDGEWIDTH?**

<br>

Here I used generalised additive models with negative binomial regression to regress bridgewidths on HIV status of the participant before enterring our study. In these models, the participant is the unit of observation and only participants reporting more than one partner in the previous year were included. Separate models were created for men and women, as well as imputed datasets. The models adjust for age(smooth term) and race. 

<br>

```{r bw_hiv_setup, include = FALSE, warning = FALSE}
# Exclude complete cases dataframe
# Keep only participants with more than one relationship in the past year
impsex <- partdfimp %>% 
  filter(.imp != 0) %>%
  group_by(.imp, sex) 

# Summarize the median and IQR of bW by sex and dataset
# Among those with more than 1 partner
bwbyimpsex <- impsex %>%
  filter(relcount > 1) %>%
  summarise(n = n(),
            Median = median(bridgewidth),
            Mean = mean(bridgewidth),
            sd = sd(bridgewidth),
            lwr = summary(bridgewidth)[[2]],
            upr = summary(bridgewidth)[[5]])

# Nest all the datasets by sex and imputation
impsexbw <- impsex %>% 
  filter(relcount > 1) %>%
  nest()

# Does HIV predict bridgewidths (neg bin models)?
# Does HIV predict whether a participant had a concurrent rel in past year (logistic models)?

tidysum <- impsexbw %>% # A model will be applied to all imputations and sex
  mutate(modelbw = map(data, bwmodel),
         modelsumbw = map(modelbw, tidygam), # Create tidy summary of each model and store as modelsum var in nested df
         predsbwage = map(modelbw, gampredsage)) # Create predictions across dif vals of age (our spline var))

# Unnest the tidy summary, to see the tidy model estimates for each model
bwmodcoef <- tidysum %>%
  unnest(modelsumbw, .drop = TRUE) 

# Unnest the tidy summary, to see the tidy model predictions for values of age
# for each model
bwmodpredage <- tidysum %>%
  unnest(predsbwage, .drop = TRUE)

```



```{r pool_bw_coef, include = FALSE, warning = FALSE}

# Now we want to produce a pooled beta for HIV according to 
# Rubin's rules. To do this we use mice functions

part <- partdfimp %>% # Take original participant-level imputed df
   filter(relcount > 1) %>% # Only participants who had more than one rel
   as.mids() # Create mids object
 
bwmodpoolm <- part %>%
   with(
     gam(bridgewidth ~ hiv + s(age) + race,
         family = nb(),
         subset = (sex == "Male"))
     ) %>%
   pool() %>% # Pool coefficients according to Rubin's Rules
   summary() %>%
   exp() %>%
   round(2) 
 
bwmodpoolw <- part %>%
   with(
     gam(bridgewidth ~ hiv + s(age) + race,
         family = nb(),
         subset = (sex == "Female"))
     ) %>%
   pool() %>% # Pool according to Rubin's Rules
   summary() %>%
   exp() %>%
   round(2) 
 
 menEBWR <- bwmodpoolm[2, 1] # Extract HIV EBWR 
 menEBWRlwr <- bwmodpoolm[2, 6] # Extract HIV lower CI limit
 menEBWRupr <- bwmodpoolm[2, 7] # Extract HIV upper CI limit
 womenEBWR <- bwmodpoolw[2, 1]
 womenEBWRlwr <- bwmodpoolw[2, 6]
 womenEBWRupr <- bwmodpoolw[2, 7]
 
 
```


```{r bw_dist_figs_setup, include = FALSE, warning = FALSE}
bwdf <- partdfimp %>% 
  filter(.imp != 0 &
           relcount > 1) 
```


<br>

###### **Figure 3. Distribution of bridge widths for each imputed dataset, by sex and HIV status.**

<br>

```{r bw_hiv_density_fig, echo = FALSE, warning = FALSE}

# Check spread of bridgwidths for each grouped dataset
bwhivfig <- bwdf %>%
  ggplot(aes(x = bridgewidth, group = .imp)) +
  geom_density(adjust = 2) +
  facet_grid(hiv ~ sex) +
  xlab("bridgewidth") +
  ylab("Density") +
  theme

bwhivfig
```

<br>

###### **Figure 4. Distribution of bridge widths for each imputed dataset, by sex and agegroup.**

<br>

```{r bw_age_density_fig, echo = FALSE, warning = FALSE}

# Check spread of bridgwidths for each grouped dataset
bwagefig <- bwdf %>%
  ggplot(aes(x = bridgewidth, group = .imp)) +
  geom_density(adjust = 2) +
  facet_grid(agegroup ~ sex) +
  xlab("bridgewidth") +
  ylab("Density") +
  theme

bwagefig
```
<br>

###### **Figure 5. Model coefficients for relationship between HIV and bridgewidth.**

<br>

```{r bw_hiv_fig, echo = FALSE, warning = FALSE}

ticks <- c(0.5, 1.0, 2.0, 4.0)

 label <- c(
   paste0("Pooled EBWR: ", menEBWR, "(", menEBWRlwr, "-", menEBWRupr, ")"),
   paste0("Pooled EBWR: ", womenEBWR, "(", womenEBWRlwr, "-", womenEBWRupr, ")")
 )

# Plot all the b's for each imputed dataset by sex
# Annotate with the pooled coefficient from above
bwhivfig <- bwmodcoef %>%
  filter(term == "hivPositive") %>%
  ggplot(aes(x = .imp, ratio)) +
   geom_hline(yintercept = 1, 
             color = "blue") +
  geom_point() +
  geom_pointrange(aes(ymax = rupr,
                      ymin = rlwr)) +
  facet_grid(sex ~ .) +
  xlab("Imputation") +
  ylab("Expected Bridge Width Ratio") +
  scale_y_log10(breaks = ticks) +
   annotate("text", x = 40, y = 6.5, label = label) +
  theme

bwhivfig
```


<br>

###### **Figure 6. Expected bridge widths for different values of age (smooth term), by gender.**

<br>

```{r bw_age_fig, echo = FALSE, warning = FALSE}

# Plot expected BW's for different values of age (or spline variable)
# Spaghetti plot to show each line for dataset by gender
bwagefig <- bwmodpredage %>%
  ggplot(aes(x = age, y = pred, group = .imp)) +
  geom_line(aes(alpha = 0.05)) +
  facet_grid(. ~ sex) +
  xlab("Age") +
  ylab("Expected Bridge Width") +
  guides(alpha = "none") +
  theme

bwagefig

```



```{r close, include = FALSE, warning = FALSE}
# ====================================================
# Detach libraries and remove objects from environment
# ====================================================
Vectorize(detach)(name = paste0("package:", c("tidyverse", "mice", "gamm4",
                                              "mgcv", "modelr", "broom", "nlme", 
                                              "mediation", "MASS", "magrittr")), 
                  unload = TRUE, 
                  character.only = TRUE)

rm(list=ls())

```

