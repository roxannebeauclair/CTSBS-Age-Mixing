---
title: "CTSBS Age-Mixing"
author: "Roxanne Beauclair"
date: '`r format(Sys.Date(), "%d %b %Y")`'
output: html_document
---

```{r setup, include = FALSE}
# ===================
# Relative file paths
# ===================
wd <- "/Users/roxannebeauclair/Documents/Analytical Projects/PhD/CTSbS Age Mixing/Analysis"
cdata <- paste0(wd, "/Data/Cleaned")

concurdata <- paste0(cdata, "/ctsbs_concur_added_data.rda")
imputedata <- paste0(cdata, "/ctsbs_impute_data.rda")
imputedatapart <- paste0(cdata, "/ctsbs_impute_data_part.rda")

fxn <- paste0(wd, "/Scripts/00-Functions.R")

# ====================
# Loading dependencies
# ====================
source(fxn)

# magrittr: for use of %>% operator
# tidyverse: for data management functions
# mice: for MI


InstallLoad("magrittr", "MASS", "tidyverse", 
            "mice","nlme", "lme4", "modelr",
            "mgcv", "gamm4", "broom", "splines", 
            "mediation", "forcats", "Gmisc", "htmlTable")

# =============
# Load datasets
# =============
load(imputedata)
load(imputedatapart)
load(concurdata)

# ====================
# Set specific global options
# ====================

# Set theme for plots
theme <- theme(axis.title.x = element_text(face = "bold", size = 10),
             axis.text.x  = element_text(angle = 0, face = "bold",
                                         colour = "black", size = 8),
             axis.title.y = element_text(face = "bold", size = 10),
             axis.text.y = element_text(angle = 0, 
                                        face = "bold", 
                                        colour = "black", 
                                        hjust = 0.5,
                                        size = 8),
             plot.title = element_text(lineheight = .8, face = "bold"),
             panel.grid.major = element_line(colour = 'grey82'),
             panel.grid.minor = element_line(colour = NA),
             panel.background = element_rect(fill = 'white'),
             strip.background = element_rect(fill = 'white'),
             strip.text = element_text(size = 8, face = "bold"),
             legend.title = element_text(colour = "black", size = 9, face = "bold"),
             legend.text = element_text(size = 8, face = "bold"),
             plot.margin = unit(c(1.5,1,1,1), "lines"))


# Initialize table counter
options(show.signif.stars = F)
```


```{r df_description, include = FALSE}
# How many exclusions due to sexuality
df1 <- df %>%
  filter(sexorientation != "both" | is.na(sexorientation)) %>%
  filter((sex == "Male" & sexorientation == "Women") |
           ((sex == "Female" & sexorientation == "Men")) |
              (is.na(sex))) 

n_sexuality <- nrow(df) - nrow(df1)

# How many exclusions due to race
df2 <- df1 %>%
  filter(race == "Coloured" | 
           race == "Black" |
           is.na(race)) 

n_race <- nrow(df1) - nrow(df2)

# How many exclusions due to no parter reported
df3 <- df2 %>%
  filter(partner != 0) 

n_nopart <- nrow(df2) - nrow(df3)

# How many relationships left
rels_left <- nrow(df3)

# How many participants left
parts_left <- df3 %>%
  distinct(id) %>%
  nrow()

imp <- max(as.integer(dfimp$.imp)) - 1

# How many relationships started in the last year
df4 <- df3 %>%
  mutate(start = as.factor(ifelse(!is.na(start), "Last year", "before last year"))) %>%
  filter(start == "Last year")

rels_last_year <- nrow(df4)

# How many participants had more than 1 relationship
df5 <- partdfimp %>%
  filter(.imp ==23) %>%
  filter(relcount > 1)

parts_many_partner <- nrow(df5)

rm(df, df1, df2, df3, df4, df5)

```

<br>

**Research questions:** 

1. Describe the age-mixing pattern in the CTSBS population. Does the age-mixing pattern of HIV positive participants differ from the general population?
2. At the individual-level are large ranges in partner ages (bridgewidths) associated with HIV status of a participant?
3. Large bridgewidths may make it possible for participants to acquire HIV from one age group and transmit to the next, but are they also associated with risky sexual behaviours among participants?

Before conducting imputations, I excluded participants who said their sexual preferences were for "both" genders or the same gender (n = `r n_sexuality`). I further excluded people who did not identify as black or coloured (n = `r n_race`) and people who did not report partners in the previous year (n = `r n_nopart`). Participants who had missing observations on those characteristics were left in the dataset. This left `r rels_left` relationships reported by `r parts_left` participants. Of the `r parts_left` participants, `r parts_many_partner` reported more than one relationship in the previous year. I imputed `r imp` datasets using the random forest method for continuous and nominal categorical variables and the "polr" method for our ordinal variables. 

```{r amp_setup, include = FALSE}

# What is the age mixing pattern?
set.seed(4762)
n <- sample(1:imp, 1)

# Smaller datasets
dfamp <- dfimp %>%
  filter(.imp == n) %>%
  select(id, age, age0, agep, sex,
         missage, missagep, hiv) 

# HIV negative
dfampm <- dfamp %>%
  filter(sex == "Male" & hiv == "Negative")

dfampw <- dfamp %>%
  filter(sex == "Female" & hiv == "Negative")


# Now fit separate models for men and women
ampmodm <- lme(agep ~ age0, 
           data = dfampm, 
           random = ~1 | id,
           weights = varPower(value = 0.5, form = ~age0 + 1),
           method = "REML")

ampmodw <- lme(agep ~ age0, 
           data = dfampw, 
           random = ~1 | id,
           weights = varPower(value = 0.5, form = ~age0 + 1),
           method = "REML")

# Add the predicted values and residuals to the dataset
dfampm <- dfampm %>%
  mutate(pred = predict(ampmodm, newdata = ., level = 0)) %>%
  add_residuals(ampmodm, var = "resid")

dfampw <- dfampw %>%
  mutate(pred = predict(ampmodw, newdata = ., level = 0)) %>%
  add_residuals(ampmodw, var = "resid") 

#Combine both datasets again
comb <- bind_rows(dfampm, dfampw)

# For only those with HIV

dfamphiv <- dfimp %>%
  filter(.imp == n) %>%
  select(id, age, age0, agep, sex,
         missage, missagep, hiv)

dfamphivm <- dfamphiv %>%
  filter(sex == "Male" & hiv == "Positive")

dfamphivw <- dfamphiv %>%
  filter(sex == "Female" & hiv == "Positive")


# Now fit separate models for men and women
amphivmodm <- lme(agep ~ age0, 
           data = dfamphivm, 
           random = ~1 | id,
           weights = varPower(value = 0.5, form = ~age0 + 1),
           method = "REML")

amphivmodw <- lme(agep ~ age0, 
           data = dfamphivw, 
           random = ~1 | id,
           weights = varPower(value = 0.5, form = ~age0 + 1),
           method = "REML")


# Add the predicted values to the dataset
dfamphivm <- dfamphivm %>%
  mutate(pred = predict(amphivmodm, newdata = ., level = 0))%>%
  add_residuals(amphivmodm, var = "resid")

dfamphivw <- dfamphivw %>%
  mutate(pred = predict(amphivmodw, newdata = ., level = 0)) %>%
  add_residuals(amphivmodw, var = "resid")

#Combine both male and female HIV datasets again
comb2 <- bind_rows(dfamphivm, dfamphivw) 

# Now add the HIV dataset to the negative dataset
comb_all <- bind_rows(comb, comb2)
  
```

<br>

### **AGE-MIXING PATTERN**

<br>

Here I used linear mixed effects models that were stratified by sex and contained a random intercept for the participant. For the plots, I randomly selected an imputed dataset to visualize the pattern in that population. I did not explicitly model heteroskedastic variance, like we did with the LNS data, because plots of the residuals did not seem to indicate increasing variance with age.

<br>

###### **Figure 1. Age mixing pattern for randomly selected imputed dataset. The top row represents the male and female age mixing patterns HIV negative study population, while the bottom row is for only those with HIV**

<br>

```{r amp_fig, echo = FALSE, warning = FALSE}
# Figure visualizing the age mixing pattern
ampfig <- comb_all %>%
  ggplot(aes(x = age, y = pred)) +
  geom_point(aes(x = age, 
                 y = agep, 
                 color = missagep), 
             position = position_jitter(width = 0.75, height = 0.75),
             size = 1) +
  geom_abline(size = 1, 
              aes(intercept = 0, slope = 1, linetype = "Same age"), 
              show.legend = FALSE) +
  geom_line(aes(linetype = "Population mean"), 
            size = 1) +
  facet_grid(hiv ~ sex) + 
  scale_y_continuous(name = "Partner's ages") +
  scale_color_manual('Imputation Status', values = c('grey70', 'grey42')) +
  scale_linetype_manual('Lines', values = c("Population mean" = 1, 'Same age' = 2)) +
  xlab("Participant's age") +
  guides(linetype = guide_legend(keywidth = 2, keyheight = 1)) +
  theme

ampfig

```


```{r amp_res_fig, include = FALSE, warning = FALSE}
# Visualizing spread of residuals for lm 
ampresfig1 <- comb_all %>%
  ggplot(aes(resid)) +
  geom_freqpoly(binwidth = 0.5) +
  facet_grid(hiv ~ sex) +
  theme

ampresfig1

# Visualizing pattern of residuals for lm 
ampresfig2 <- comb_all %>%
  ggplot(aes(x = age, y = resid)) +
  geom_point() +
  geom_smooth(method = "loess") +
  geom_ref_line(h = 0) +
  facet_grid(hiv ~ sex) + 
  theme

ampresfig2

```

```{r amp_all_setup, include = FALSE, warning = FALSE}

# Create a dataset that nests all of the datasets according to
# gender, imputation, and hiv status. So with 2 genders, 50 imps, and 2 hiv status,
# there will be 200 groups/dataframes

impsexhivamp <- dfimp %>%
  filter(.imp != 0)%>%
  group_by(.imp, sex, hiv) %>%
  nest()

# Produce nice summary of the models
# A model will be applied to all imputations, sex, and hiv subgroups
tidysumamp <- impsexhivamp %>%
  mutate(model = map(data, ampmodel), #ampmodel is function for nlme amp model
         modelsum = map(model, ~tidy(.x, effects = "fixed")), # Obtaining all the b's and intercepts from the models
         bvar = map(model, bvar), # Obtaining between subject variance using function bvar
         wvar = map(model, wvar), # Obtaining within subject variance using function wvar
         power = map(model, power), # Obtaining power coefficient using function power
         model2 = map(data, ampmodel2),
         modelsum2 = map(model2, ~tidy(.x, effects = "fixed")),
         bvar2 = map(model2, bvar2),
         wvar2 = map(model2, wvar2))

# Unnest tidy summary for (lme) data on slope and intercept
# of all the models
modslopeint <- tidysumamp %>%
  unnest(modelsum, .drop = TRUE)

# Unnest tidy summary for (lme) data on within individual variance
modwvar <- tidysumamp %>%
  unnest(wvar, .drop = TRUE)

# Uneest tidy summary for (lme) data on between individual variance
modbvar <- tidysumamp %>%
  unnest(bvar, .drop = TRUE)

# Unnest tidy summary for (lme) data on power coefficient
modpower <- tidysumamp %>%
  unnest(power, .drop = TRUE)

# Unnest tidy summary for (lmer) data on slope and intercept
# of all the models
modslopeint2 <- tidysumamp %>%
  unnest(modelsum2, .drop = TRUE)

# Unnest tidy summary for (lmer) data on within individual variance
modwvar2 <- tidysumamp %>%
  unnest(wvar2, .drop = TRUE)

# Uneest tidy summary for (lmer) data on between individual variance
modbvar2 <- tidysumamp %>%
  unnest(bvar2, .drop = TRUE)

```

<br>

###### **Figure 2. Extractions of model slopes, intercepts, intercept variance and residual variance for each imputed dataset. The top row represents the male and female age mixing patterns in the whole study population, while the bottom row is for only those with HIV**

<br>

```{r amp_model_slope_plot, echo = FALSE, warning = FALSE, fig.height = 8}

# Plot all of the beta's for age mixing pattern in 
# each of the 100 datasets (by imputation and gender)
slopeplot <- modslopeint %>%
  filter(term == "age0") %>%
  ggplot(aes(x = .imp, y = estimate)) +
  geom_point() +
  geom_pointrange(aes(ymax = estimate + 2 * std.error,
                      ymin = estimate - 2 * std.error)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  xlab("Imputation") +
  ylab("Slope of regression line") +
  theme

slopeplot
```

```{r amp_model_slope_plot2, echo = FALSE, warning = FALSE, fig.height = 8}

# Plot all of the beta's for age mixing pattern in 
# each of the 100 datasets (by imputation and gender)
slopeplot2 <- modslopeint2 %>%
  filter(term == "age0") %>%
  ggplot(aes(x = .imp, y = estimate)) +
  geom_point() +
  geom_pointrange(aes(ymax = estimate + 2 * std.error,
                      ymin = estimate - 2 * std.error)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  xlab("Imputation") +
  ylab("Slope of regression line") +
  theme

slopeplot2
```


```{r amp_model_intercept_plot, echo = FALSE, warning = FALSE, fig.height = 8}
# Plot all of the intercepts for age mixing pattern in 
# each of the 100 datasets (by imputation and gender)
interplot <- modslopeint %>%
  filter(term == "(Intercept)") %>%
  ggplot(aes(.imp, estimate)) +
  geom_point() +
  geom_pointrange(aes(ymax = estimate + 2 * std.error,
                      ymin = estimate - 2 * std.error)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  xlab("Imputation") +
  ylab("Partner age for 15 year olds") +
  theme

interplot
```

```{r amp_model_intercept_plot2, echo = FALSE, warning = FALSE, fig.height = 8}
# Plot all of the intercepts for age mixing pattern in 
# each of the 100 datasets (by imputation and gender)
interplot2 <- modslopeint2 %>%
  filter(term == "(Intercept)") %>%
  ggplot(aes(.imp, estimate)) +
  geom_point() +
  geom_pointrange(aes(ymax = estimate + 2 * std.error,
                      ymin = estimate - 2 * std.error)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  xlab("Imputation") +
  ylab("Partner age for 15 year olds") +
  theme

interplot2
```

```{r amp_model_wvar_plot, echo = FALSE, warning = FALSE, fig.height = 8}
# Plot each of the residual variances for age mixing pattern
# in each of the 100 datasets (by imputation and gender)
wvarplot <- modwvar %>%
  ggplot(aes(.imp, wsd)) +
  geom_point() +
  geom_pointrange(aes(ymax = uprwsd,
                      ymin = lwrwsd)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  xlab("Imputation") +
  ylab("Within-Subject SD") +
  theme

wvarplot
```

```{r amp_model_wvar_plot2, echo = FALSE, warning = FALSE, fig.height = 8}
# Plot each of the residual variances for age mixing pattern
# in each of the 100 datasets (by imputation and gender)
wvarplot2 <- modwvar2 %>%
  ggplot(aes(.imp, wsd)) +
  geom_point() +
  geom_pointrange(aes(ymax = uprwsd,
                      ymin = lwrwsd)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  xlab("Imputation") +
  ylab("Within-Subject SD") +
  theme

wvarplot2
```

```{r amp_model_bvar_plot, echo = FALSE, warning = FALSE, fig.height = 8}
# Plot each of the between subject variances for age mixing pattern
# in each of the 100 datasets (by imputation and gender)
bvarplot <- modbvar %>%
  ggplot(aes(.imp, bsd)) +
  geom_point() +
  geom_pointrange(aes(ymax = uprbsd,
                      ymin = lwrbsd)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  scale_y_continuous(limits = c(0, 20)) +
  xlab("Imputation") +
  ylab("between-Subject SD") +
  theme

bvarplot
```

```{r amp_model_bvar_plot2, echo = FALSE, warning = FALSE, fig.height = 8}
# Plot each of the between subject variances for age mixing pattern
# in each of the 100 datasets (by imputation and gender)
bvarplot2 <- modbvar2 %>%
  ggplot(aes(.imp, bsd)) +
  geom_point() +
  geom_pointrange(aes(ymax = uprbsd,
                      ymin = lwrbsd)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  scale_y_continuous(limits = c(0, 20)) +
  xlab("Imputation") +
  ylab("between-Subject SD") +
  theme

bvarplot2
```

<br>

For some of the models on the some datasets (e.g. impution 9 in the HIV positive female sub-population), I recieved this error message when trying to obtain the CIs for the between-subject (intercept) SD: "cannot get confidence intervals on var-cov components: Non-positive definite approximate variance-covariance". According to Jose Pinheiro, this "indicates that, although the optimization algorithm converged (according to the criteria defined in the ms() function), the Hessian matrix calculated at the converged values was not negative-definite
and therefore an approximate covariance matrix for the MLE's could not be obtained. This is generally caused by a flat log-likelihood surface, for which the algorithm decided that no further improvements were possible and declared convergence. This is an indication that the model may be overparameterized and that you should cut down in the
number of parameters." 


```{r amp_model_power_plot, echo = FALSE, warning = FALSE, fig.height = 8}

# The formula to calculate the weights for variance is |v|^(2*t)
# I belive t is the power coefficient

powplot <- modpower %>%
  ggplot(aes(.imp, power)) +
  geom_point() +
  geom_pointrange(aes(ymax = uprpow,
                      ymin = lwrpow)) +
  facet_grid(hiv ~ sex) +
  coord_flip() +
  #scale_y_continuous(limits = c(0, 20)) +
  xlab("Imputation") +
  ylab("Power variance function coefficient") +
  theme

powplot
```

In the power variance function coefficient plot, there were 20 imputations removed because "Non-positive definite approximate variance-covariance".

```{r age_hiv_fig, include = FALSE, warning = FALSE, fig.height = 8}
# Create dataframe that summarizes the proportion of relationships
# in different partner age groups for people who are HIV
# positive
hivbyage <- impsexhivamp %>%
  unnest() %>%
  ungroup() %>%
  filter(.imp == n & hiv == "Positive") %>%
  group_by(sex, agepgroup) %>%
  summarise(n = n()) %>%
  mutate(prop = round((n / sum(n)) * 100, 2))

# barplot of fraction of relationships in different partner age groups  
hivageplot <- hivbyage %>%
  ggplot(aes(x = agepgroup, y = prop, fill = sex)) +
  geom_bar(stat = "identity",
           position = position_dodge()) +
  xlab("Age group of partner") +
  ylab("Proportion of relationships") +
  scale_fill_brewer(palette = "Dark2") +
  theme

hivageplot
  
```

<br>

### **DO BRIDGEWIDTHS AND SD'S GROW WITH AGE?**

```{r bw_age_sd_setup, include = FALSE}
bwdfm <- partdfimp %>%
  filter(.imp == n) %>%
  filter(sex == "Male") %>%
  select(agegroup, bridgewidth) %>%
  group_by(agegroup) %>%
  summarise(n = n(),
            Mean = round(mean(bridgewidth), 2),
            sd = round(sd(bridgewidth), 2),
            SEM = round((sd/sqrt(n)), 2)) %>%
  rename(SD = sd) %>%
  data.frame(row.names = 1) %>%
  format(nsmall = 1)
  

bwdfw <- partdfimp %>%
  filter(.imp == n) %>%
  filter(sex == "Female") %>%
  select(agegroup, bridgewidth) %>%
  group_by(agegroup) %>%
  summarise(n = n(),
            Mean = round(mean(bridgewidth), 2),
            sd = round(sd(bridgewidth), 2),
            SEM = round((sd/sqrt(n)), 2)) %>%
  rename(SD = sd) %>%
  data.frame(row.names = 1) %>%
  format(nsmall = 1)
  
```

```{r bw_age_sd_table, echo = FALSE}

htmlTable(cbind(bwdfm, bwdfw),
          caption = "<b>Table 1. Mean bridgewidth by age category and gender in randomly selected imputed dataset<b/>",
          ctable = TRUE,
          tfoot = txtMergeLines("SD, Standard Deviation",
                                "SEM, Standard Error of the Mean"),
          cgroup = c("Male", "Female"),
          n.cgroup = c(4,4),
          rowlabel = "Age category")

```


<br>

### **DOES HIV STATUS PREDICT BRIDGEWIDTH?**

<br>

Here I used generalised additive models with negative binomial regression to regress bridgewidths on HIV status of the participant before enterring our study. In these models, the participant is the unit of observation and only participants reporting more than one partner in the previous year were included. Separate models were created for men and women, as well as imputed datasets. The models adjust for age(smooth term) and race. 

<br>

```{r bw_hiv_setup, include = FALSE, warning = FALSE}
# Exclude complete cases dataframe
# Keep only participants with more than one relationship in the past year
impsex <- partdfimp %>% 
  filter(.imp != 0) %>%
  mutate(cf = fct_collapse(partcf,
                           "Never/inconsistent" = c("Never", "Inconsistent"))) %>%
  group_by(.imp, sex) 

# Summarize the median and IQR of bW by sex and dataset
# Among those with more than 1 partner
bwbyimpsex <- impsex %>%
  filter(relcount > 1) %>%
  summarise(n = n(),
            Median = median(bridgewidth),
            Mean = mean(bridgewidth),
            sd = sd(bridgewidth),
            lwr = summary(bridgewidth)[[2]],
            upr = summary(bridgewidth)[[5]])

# Nest all the datasets by sex and imputation
impsexbw <- impsex %>% 
  filter(relcount > 1) %>%
  nest()

# Does HIV predict bridgewidths (neg bin models)?
# Does HIV predict whether a participant had a concurrent rel in past year (logistic models)?

tidysum <- impsexbw %>% # A model will be applied to all imputations and sex
  mutate(modelbw = map(data, bwmodel), # bwmodel is function for nb bw model, model as stored as var in nested df
         # modelmcp = map(data, mcpmodel),
         modelmcpbw = map(data, mcpbwmodel),
         modelmcpfull = map(data, ~mcpmodel(.x, med = TRUE)),
         modelsumbw = map(modelbw, tidygam), # Create tidy summary of each model and store as modelsum var in nested df
         # modelsummcp = map(modelmcp, tidygam),
         modelsumbwmcp = map(modelmcpbw, tidygam),
         modelsummcpfull = map(modelmcpfull, tidygam),
         predsbwage = map(modelbw, gampredsage), # Create predictions across dif vals of age (our spline var) 
         # predsmcpage = map(modelmcp, gampredsage),
         predsbwmcpage = map(modelmcpbw, gampredsage),
         predsmcpfullage = map(modelmcpfull, gampredsage))

# Unnest the tidy summary, to see the tidy model estimates for each model
bwmodcoef <- tidysum %>%
  unnest(modelsumbw, .drop = TRUE) 

# mcpmodcoef <- tidysum %>%
#   unnest(modelsummcp, .drop = TRUE)

mcpbwmodcoef <- tidysum %>%
  unnest(modelsumbwmcp, .drop = TRUE)

mcpfullmodcoef <- tidysum %>%
  unnest(modelsummcpfull, .drop = TRUE)

# Unnest the tidy summary, to see the tidy model predictions for values of age
# for each model
bwmodpredage <- tidysum %>%
  unnest(predsbwage, .drop = TRUE)

# mcpmodpredage <- tidysum %>%
#   unnest(predsmcpage, .drop = TRUE)

mcpbwmodpredage <- tidysum %>%
  unnest(predsbwmcpage, .drop = TRUE)

mcpfullmodpredage <- tidysum %>%
  unnest(predsmcpfullage, .drop = TRUE)

```


```{r sb_hiv_setup, include = FALSE, warning = FALSE}
# Exclude complete cases dataframe
# Keep only participants with more than one relationship in the past year
# Relationship-level sex behaviours
impsexsb <- dfimp %>% 
  filter(.imp != 0 & 
           relcount > 1) %>%
  mutate(cf = fct_collapse(relcf,
                           "Never/inconsistent" = c("Never", "Inconsistent"))) %>%
  group_by(.imp, sex) %>%
  nest()

# Does HIV predict condom use in relationships among people who had more than one relationships?
# Does HIV predict sex freq in relationships among people who had more than one relationship?

# Model must use lmer (instead of lme) because of mediation analyis (if mediate is used)

tidysummed <- impsexsb %>%
  mutate(# modelcf = map(data, cfmodel),
         modelcfbw = map(data, cfbwmodel),
         modelcffull = map(data, ~cfmodel(.x, med = TRUE)),
         # modelsf = map(data, sfmodel),
         modelsfbw = map(data, sfbwmodel),
         modelsffull = map(data, ~sfmodel(.x, med = TRUE)),
         # modelsumcf = map(modelcf, tidygam),
         modelsumcfbw = map(modelcfbw, tidygam),
         modelsumcffull = map(modelcffull, tidygam),
         # modelsumsf = map(modelsf, tidygam),
         modelsumsfbw = map(modelsfbw, tidygam),
         modelsumsffull = map(modelsffull, tidygam),
         # predcfage = map(modelcf, gampredsage),
         predcfbwage = map(modelcfbw, gampredsage),
         predcffullage = map(modelcffull, gampredsage),
         # predsfage = map(modelsf, gampredsage),
         predsfbwage = map(modelsfbw, gampredsage),
         predsffullage = map(modelsffull, gampredsage))

tidysummed


# Unnest the tidy gam cf summary, to see tidy model estimates
# cfmodcoef <- tidysummed %>%
#   unnest(modelsumcf, .drop = TRUE)
# 
# cfmodcoef

# # Unnest the tidy gam sf summary, to see tidy model estimates
# sfmodcoef <- tidysummed %>%
#   unnest(modelsumsf, .drop = TRUE)
# 
# sfmodcoef

# Unnest the tidy gam cfbw summary, to see tidy model estimates
cfbwmodcoef <- tidysummed %>%
  unnest(modelsumcfbw, .drop = TRUE)

cfbwmodcoef

# Unnest the tidy gam sfbw summary, to see tidy model estimates
sfbwmodcoef <- tidysummed %>%
  unnest(modelsumsfbw, .drop = TRUE)

sfbwmodcoef

# Unnest the tidy gam full cf summary, to see tidy model estimates
cffullmodcoef <- tidysummed %>%
  unnest(modelsumcffull, .drop = TRUE)

cffullmodcoef

# Unnest the tidy gam full sf summary, to see tidy model estimates
sffullmodcoef <- tidysummed %>%
  unnest(modelsumsffull, .drop = TRUE)

sffullmodcoef

# Unnest the tidy summary, to see the tidy model predictions for values of age
# for each gamm model
# cfmodpredage <- tidysummed %>%
#   unnest(predcfage, .drop = TRUE)
# 
# cfmodpredage


# sfmodpredage <- tidysummed %>%
#   unnest(predsfage, .drop = TRUE)
# 
# sfmodpredage


cfbwmodpredage <- tidysummed %>%
  unnest(predcfbwage, .drop = TRUE)

cfbwmodpredage


sfbwmodpredage <- tidysummed %>%
  unnest(predsfbwage, .drop = TRUE)

sfbwmodpredage

cffullmodpredage <- tidysummed %>%
  unnest(predcffullage, .drop = TRUE)

cffullmodpredage


sffullmodpredage <- tidysummed %>%
  unnest(predsffullage, .drop = TRUE)

sffullmodpredage
```


```{r pool_bw_coef, include = FALSE, warning = FALSE}

# Now we want to produce a pooled beta for HIV according to 
# Rubin's rules. To do this we use mice functions

part <- partdfimp %>% # Take original participant-level imputed df
   filter(relcount > 1) %>% # Only participants who had more than one rel
   as.mids() # Create mids object
 
bwmodpoolm <- part %>%
   with(
     gam(bridgewidth ~ hiv + s(age) + race,
         family = nb(),
         subset = (sex == "Male"))
     ) %>%
   pool() %>% # Pool coefficients according to Rubin's Rules
   summary() %>%
   exp() %>%
   round(2) 
 
bwmodpoolw <- part %>%
   with(
     gam(bridgewidth ~ hiv + s(age) + race,
         family = nb(),
         subset = (sex == "Female"))
     ) %>%
   pool() %>% # Pool according to Rubin's Rules
   summary() %>%
   exp() %>%
   round(2) 

# mcpmodpoolm <- part %>%
#    with(
#      gam(partconcur ~ hiv + s(age) + race,
#          family = binomial,
#          subset = (sex == "Male"))
#      ) %>%
#    pool() %>% # Pool coefficients according to Rubin's Rules
#    summary() %>%
#    exp() %>%
#    round(2) 
#  
# mcpmodpoolw <- part %>%
#    with(
#      gam(partconcur ~ hiv + s(age) + race,
#          family = binomial,
#          subset = (sex == "Female"))
#      ) %>%
#    pool() %>% # Pool according to Rubin's Rules
#    summary() %>%
#    exp() %>%
#    round(2) 

mcpbwmodpoolm <- part %>%
   with(
     gam(partconcur ~ bridgewidth + s(age) + race,
         family = binomial,
         subset = (sex == "Male"))
     ) %>%
   pool() %>% # Pool coefficients according to Rubin's Rules
   summary() %>%
   exp() %>%
   round(2) 
 
mcpbwmodpoolw <- part %>%
   with(
     gam(partconcur ~ bridgewidth + s(age) + race,
         family = binomial,
         subset = (sex == "Female"))
     ) %>%
   pool() %>% # Pool according to Rubin's Rules
   summary() %>%
   exp() %>%
   round(2) 

mcpfullmodpoolm <- part %>%
   with(
     gam(partconcur ~ bridgewidth + s(age) + hiv + race,
         family = binomial,
         subset = (sex == "Male"))
     ) %>%
   pool() %>% # Pool coefficients according to Rubin's Rules
   summary() %>%
   exp() %>%
   round(2) 
 
mcpfullmodpoolw <- part %>%
   with(
     gam(partconcur ~ bridgewidth + s(age) + hiv + race,
         family = binomial,
         subset = (sex == "Female"))
     ) %>%
   pool() %>% # Pool according to Rubin's Rules
   summary() %>%
   exp() %>%
   round(2) 
 
 menEBWR <- bwmodpoolm[2, 1] # Extract HIV EBWR 
 menEBWRlwr <- bwmodpoolm[2, 6] # Extract HIV lower CI limit
 menEBWRupr <- bwmodpoolm[2, 7] # Extract HIV upper CI limit
 womenEBWR <- bwmodpoolw[2, 1]
 womenEBWRlwr <- bwmodpoolw[2, 6]
 womenEBWRupr <- bwmodpoolw[2, 7]
 
 # menor <- mcpmodpoolm[2, 1]  
 # menorlwr <- mcpmodpoolm[2, 6] 
 # menorupr <- mcpmodpoolm[2, 7] 
 # womenor <- mcpmodpoolw[2, 1]
 # womenorlwr <- mcpmodpoolw[2, 6]
 # womenorupr <- mcpmodpoolw[2, 7]
 
 
 mcpbwmenor <- mcpbwmodpoolm[2, 1]  
 mcpbwmenorlwr <- mcpbwmodpoolm[2, 6] 
 mcpbwmenorupr <- mcpbwmodpoolm[2, 7] 
 mcpbwwomenor <- mcpbwmodpoolw[2, 1]
 mcpbwwomenorlwr <- mcpbwmodpoolw[2, 6]
 mcpbwwomenorupr <- mcpbwmodpoolw[2, 7]
 
 # BW
 mcpfullbwmenor <- mcpfullmodpoolm[2, 1]  
 mcpfullbwmenorlwr <- mcpfullmodpoolm[2, 6] 
 mcpfullbwmenorupr <- mcpfullmodpoolm[2, 7] 
 mcpfullbwwomenor <- mcpfullmodpoolw[2, 1]
 mcpfullbwwomenorlwr <- mcpfullmodpoolw[2, 6]
 mcpfullbwwomenorupr <- mcpfullmodpoolw[2, 7]
 
 # HIV
 mcpfullhivmenor <- mcpfullmodpoolm[3, 1]  
 mcpfullhivmenorlwr <- mcpfullmodpoolm[3, 6] 
 mcpfullhivmenorupr <- mcpfullmodpoolm[3, 7] 
 mcpfullhivwomenor <- mcpfullmodpoolw[3, 1]
 mcpfullhivwomenorlwr <- mcpfullmodpoolw[3, 6]
 mcpfullhivwomenorupr <- mcpfullmodpoolw[3, 7]
 
```

<br>

###### **Figure 3. Distribution of bridge widths for each imputed dataset, by sex and HIV status.**

<br>

```{r bw_density_fig, echo = FALSE, warning = FALSE}

# Check spread of bridgwidths for each grouped dataset
bwfig <- impsexbw %>%
  unnest() %>%
  ggplot(aes(x = bridgewidth, group = .imp)) +
  geom_density(adjust = 2) +
  facet_grid(hiv ~ sex) +
  xlab("bridgewidth") +
  ylab("Density") +
  theme

bwfig
```


<br>

###### **Figure 4. Model coefficients for relationship between HIV and bridgewidth.**

<br>

```{r bw_hiv_fig, echo = FALSE, warning = FALSE}

ticks <- c(0.5, 1.0, 2.0, 4.0)

 label <- c(
   paste0("Pooled EBWR: ", menEBWR, "(", menEBWRlwr, "-", menEBWRupr, ")"),
   paste0("Pooled EBWR: ", womenEBWR, "(", womenEBWRlwr, "-", womenEBWRupr, ")")
 )

# Plot all the b's for each imputed dataset by sex
# Annotate with the pooled coefficient from above
bwhivfig <- bwmodcoef %>%
  filter(term == "hivPositive") %>%
  ggplot(aes(x = .imp, ratio)) +
   geom_hline(yintercept = 1, 
             color = "blue") +
  geom_point() +
  geom_pointrange(aes(ymax = rupr,
                      ymin = rlwr)) +
  facet_grid(sex ~ .) +
  xlab("Imputation") +
  ylab("Expected Bridge Width Ratio") +
  scale_y_log10(breaks = ticks) +
   annotate("text", x = 40, y = 6.5, label = label) +
  theme

bwhivfig
```


<br>

###### **Figure 5. Expected bridge widths for different values of age (smooth term), by gender.**

<br>

```{r bw_age_fig, echo = FALSE, warning = FALSE}

# Plot expected BW's for different values of age (or spline variable)
# Spaghetti plot to show each line for dataset by gender
bwagefig <- bwmodpredage %>%
  ggplot(aes(x = age, y = pred, group = .imp)) +
  geom_line() +
  facet_grid(. ~ sex) +
  xlab("Age") +
  ylab("Expected Bridge Width") +
  theme

bwagefig

```

<br>

### **ARE LARGE BRIDGEWIDTHS ASSOCIATED WITH PARTICIPANTS HAVING A CONCURRENT RELATIONSHIP IN THE PREVIOUS YEAR?**

<br>

Here, I regressed a binary partnership-level concurrency indicator on bridgewidths using a generalized additive logistic regression model. Again, the participant was the unit of observation and only participants reporting more than one relationship in the previous year were included. Models were applied to different imputed datasets and stratified by gender. All models adjust for age(smooth term) and race. Bridgewidth was treated as a continuous linear term because exploration using GAMS indicated it should be.

###### **Figure 6. Distribution of the percentage of participants who had a concurrent relationship in the previous year, stratified by gender and across all imputations.**

<br>

```{r mcp_freq_fig, echo = FALSE, warning = FALSE}
mcpdf <- impsexbw %>%
  unnest() %>%
  group_by(.imp, sex, partconcur) %>%
  summarise(n = n()) %>%
  mutate(prop = round((n / sum(n)) * 100, 2))


mcpfig <- mcpdf %>%
  ggplot(aes(x = partconcur, y = prop)) +
  geom_boxplot() +
  facet_grid(. ~ sex) +
  xlab("Had a concurrent relationship in previous year") +
  ylab("Percentage of participants") +
  theme

mcpfig

```



```{r mcp_hiv_fig, include = FALSE, warning = FALSE}

# ticks <- c(0.5, 1.0, 2.0, 4.0)
# 
#  label <- c(
#    paste0("Pooled OR: ", menor, "(", menorlwr, "-", menorupr, ")"),
#    paste0("Pooled OR: ", womenor, "(", womenorlwr, "-", womenorupr, ")")
#  )
# 
# # Plot all the b's for each imputed dataset by sex
# # Annotate with the pooled coefficient from above
# mcphivfig <- mcpmodcoef %>%
#   filter(term == "hivPositive") %>%
#   ggplot(aes(x = .imp, ratio)) +
#    geom_hline(yintercept = 1, 
#              color = "blue") +
#   geom_point() +
#   geom_pointrange(aes(ymax = rupr,
#                       ymin = rlwr)) +
#   facet_grid(sex ~ .) +
#   xlab("Imputation") +
#   ylab("OR, Concurrent Relationship") +
#   scale_y_log10(breaks = ticks,
#                 limits = c(0.25, 16)) +
#   annotate("text", x = 40, y = 6.5, label = label) +
#   theme
# 
# mcphivfig
```

<br>

###### **Figure 7. Effect of bridgewidth (Odds Ratios, OR) on whether a participant had a concurrent relationship in the previous year, stratified by gender.** 

<br>

```{r mcp_bw_fig, echo = FALSE, warning = FALSE}

ticks <- c(0.5, 1.0, 2.0)

 label <- c(
   paste0("Pooled OR: ", mcpbwmenor, "(", mcpbwmenorlwr, "-", mcpbwmenorupr, ")"),
   paste0("Pooled OR: ", mcpbwwomenor, "(", mcpbwwomenorlwr, "-", mcpbwwomenorupr, ")")
 )

# Plot all the b's for each imputed dataset by sex
# Annotate with the pooled coefficient from above
mcpbwfig <- mcpbwmodcoef %>%
  filter(term == "bridgewidth") %>%
  ggplot(aes(x = .imp, ratio)) +
   geom_hline(yintercept = 1, 
             color = "blue") +
  geom_point() +
  geom_pointrange(aes(ymax = rupr,
                      ymin = rlwr)) +
  facet_grid(sex ~ .) +
  xlab("Imputation") +
  ylab("OR, Concurrent Relationship") +
  scale_y_log10(breaks = ticks,
                limits = c(0.50, 2)) +
  annotate("text", x = 40, y = 1.5, label = label) +
  theme

mcpbwfig
```

<br>

###### **Figure 8. Predicted probabilities of having had a concurrent relationship in the year before the survey for different values of age, by gender.**

<br>

```{r mcpbw_age_fig, echo = FALSE, warning = FALSE}

# Plot expected BW's for different values of age
# Spaghetti plot to show each line for dataset by gender
mcpbwagefig <- mcpbwmodpredage %>%
  ggplot(aes(x = age, y = pred, group = .imp)) +
  geom_line() +
  facet_grid(. ~ sex) +
  xlab("Age") +
  ylab("Probability, Concurrent Relationship") +
  theme

mcpbwagefig

```

<br>

The following plots, visualize models where we are interested in the effect of whether the HIV status of a participant was associated with them having a subsequent concurrent relationship (but in the year before the survey). In these models HIV was our exposure of interest, and bridgewidth a hypothesized mediator. Again these were adjusted for age(smooth term) and race.

<br>

###### **Figure 9. Effect of HIV (Odds Ratios, OR) on whether a participant had a concurrent relationship in the year before the survey, stratified by gender.** Many confidence intervals and ORs are not showing because there were huge, inflated CI's that were outside the limits of the y-axis.

<br>

```{r mcpfull_hiv_fig, echo = FALSE, warning = FALSE}

ticks <- c(0.5, 1.0, 2.0, 4.0)

 label <- c(
   paste0("Pooled OR: ", mcpfullhivmenor, "(", mcpfullhivmenorlwr, "-", mcpfullhivmenorupr, ")"),
   paste0("Pooled OR: ", mcpfullhivwomenor, "(", mcpfullhivwomenorlwr, "-", mcpfullhivwomenorupr, ")")
 )

# Plot all the b's for each imputed dataset by sex
# Annotate with the pooled coefficient from above
mcpfullhivfig <- mcpfullmodcoef %>%
  filter(term == "hivPositive") %>%
  ggplot(aes(x = .imp, ratio)) +
   geom_hline(yintercept = 1, 
             color = "blue") +
  geom_point() +
  geom_pointrange(aes(ymax = rupr,
                      ymin = rlwr)) +
  facet_grid(sex ~ .) +
  xlab("Imputation") +
  ylab("OR, Concurrent Relationship") +
  scale_y_log10(breaks = ticks,
                limits = c(0.25, 16)) +
  annotate("text", x = 40, y = 6.5, label = label) +
  theme

mcpfullhivfig
```

<br>

###### **Figure 10. Effect of bridgewidth (Odds Ratio, OR) on whether a participant had a concurrent relationship in the year before the survey, stratified by gender.** 

<br>

```{r mcpfull_bw_fig, echo = FALSE, warning = FALSE}

ticks <- c(0.5, 1.0, 2.0)

 label <- c(
   paste0("Pooled OR: ", mcpfullbwmenor, "(", mcpfullbwmenorlwr, "-", mcpfullbwmenorupr, ")"),
   paste0("Pooled OR: ", mcpfullbwwomenor, "(", mcpfullbwwomenorlwr, "-", mcpfullbwwomenorupr, ")")
 )

# Plot all the b's for each imputed dataset by sex
# Annotate with the pooled coefficient from above
mcpfullbwfig <- mcpfullmodcoef %>%
  filter(term == "bridgewidth") %>%
  ggplot(aes(x = .imp, ratio)) +
   geom_hline(yintercept = 1, 
             color = "blue") +
  geom_point() +
  geom_pointrange(aes(ymax = rupr,
                      ymin = rlwr)) +
  facet_grid(sex ~ .) +
  xlab("Imputation") +
  ylab("OR, Concurrent Relationship") +
  scale_y_log10(breaks = ticks,
                limits = c(0.50, 2)) +
  annotate("text", x = 40, y = 1.5, label = label) +
  theme

mcpfullbwfig
```

<br>

```{r mcp_age_fig, include = FALSE, warning = FALSE}

# # Spaghetti plot to show each line for dataset by gender
# mcpagefig <- mcpmodpredage %>%
#   ggplot(aes(x = age, y = pred, group = .imp)) +
#   geom_line() +
#   facet_grid(. ~ sex) +
#   xlab("Age") +
#   ylab("Probability, Concurrent Relationship") +
#   theme
# 
# mcpagefig

```

<br>

###### **Figure 11. Predicted probabilities of having had a concurrent relationship in the previous year for different values of age (smooth term), by gender.**

<br>

```{r mcpfull_age_fig, echo = FALSE, warning = FALSE}

# Plot expected BW's for different values of age
# Spaghetti plot to show each line for dataset by gender
mcpfullagefig <- mcpfullmodpredage %>%
  ggplot(aes(x = age, y = pred, group = .imp)) +
  geom_line() +
  facet_grid(. ~ sex) +
  xlab("Age") +
  ylab("Probability, Concurrent Relationship") +
  theme

mcpfullagefig

```

<br>

### **ARE LARGE BRIDGWIDTHS ASSOCIATED WITH USING ALWAYS USING CONDOMS IN A RELATIONSHIP?**

<br>

I regressed a binary relationship-level condom use indicator on bridgewidths using a generalized additive mixed models with a logistic outcome and random intercept for participant. The relationship was the unit of observation and only relationships from participants reporting more than one relationship in the previous year were included. Models were applied to different imputed datasets and stratified by gender. All models adjust for age(smooth term) and race. Bridgewidth was treated as a continuous linear term because exploration using GAMS indicated it should be. 
<br>

###### **Figure 12. Distribution of the proportions of relationships using condoms, stratified by sex and across all imputations**

<br>


```{r cf_freq_fig, echo = FALSE, warning = FALSE}
cfdf <- impsexsb %>%
  unnest() %>%
  group_by(.imp, sex, cf) %>%
  summarise(n = n()) %>%
  mutate(prop = round((n / sum(n)) * 100, 2))


cffig <- cfdf %>%
  ggplot(aes(x = cf, y = prop)) +
  geom_boxplot() +
  facet_grid(. ~ sex) +
  xlab("Condom use") +
  ylab("Proportion of relationships") +
  theme

cffig

```

<br>


```{r cf_hiv_fig, include = FALSE, warning = FALSE}
# ticks <- c(0.5, 1.0, 2.0, 4.0, 8.0)
# 
# cfhivfig <- cfmodcoef %>%
#   filter(term == "hivPositive") %>%
#   ggplot(aes(x = .imp, ratio)) +
#    geom_hline(yintercept = 1, 
#              color = "blue") +
#   geom_point() +
#   geom_pointrange(aes(ymax = rupr,
#                       ymin = rlwr)) +
#   facet_grid(sex ~ .) +
#   scale_y_log10(breaks = ticks) +
#   xlab("Imputation") +
#   ylab("OR, Condom Use") +
#   theme
# 
# cfhivfig

```

<br>

###### **Figure 13. Effect of bridgewidth (Odds Ratios, OR) on "Always" using a condom in relationship, stratified by gender.**

<br>

```{r cf_bw_fig, echo = FALSE, warning = FALSE}
ticks <- c(0.5, 1.0, 2.0, 4.0, 8.0)

cfbwfig <- cfbwmodcoef %>%
  filter(term == "bridgewidth") %>%
  ggplot(aes(x = .imp, ratio)) +
   geom_hline(yintercept = 1, 
             color = "blue") +
  geom_point() +
  geom_pointrange(aes(ymax = rupr,
                      ymin = rlwr)) +
  facet_grid(sex ~ .) +
  # scale_y_log10(breaks = ticks) +
  xlab("Imputation") +
  ylab("OR, Condom use") +
  theme

cfbwfig

```

<br>

###### **Figure 14. Predicted probabilities of "Always" using a condom in a relationship for different ages of participant, stratified by gender.**

<br>

```{r cfbw_age_fig, echo = FALSE, warning = FALSE}

cfbwagefig <- cfbwmodpredage %>%
  ggplot(aes(x = age, y = pred, group = .imp)) +
  geom_line() +
  facet_grid(. ~ sex) +
  xlab("Age") +
  ylab("Probability, Condom Use") +
  theme

cfbwagefig

```

<br>

The following plots, visualize models where we are interested in the effect of whether the HIV status of a participant was associated with always using a condom in relationships. In these models HIV was our exposure of interest, and bridgewidth a hypothesized mediator. Again these were adjusted for age(smooth term) and race.

<br>

###### **Figure 15. Effect of HIV (Odds Ratios, OR) on "Always" using a condom in relationship, stratified by gender.**

<br>

```{r cffull_hiv_fig, echo = FALSE, warning = FALSE}
ticks <- c(0.5, 1.0, 2.0, 4.0, 8.0)

cffullhivfig <- cffullmodcoef %>%
  filter(term == "hivPositive") %>%
  ggplot(aes(x = .imp, ratio)) +
   geom_hline(yintercept = 1, 
             color = "blue") +
  geom_point() +
  geom_pointrange(aes(ymax = rupr,
                      ymin = rlwr)) +
  facet_grid(sex ~ .) +
  scale_y_log10(breaks = ticks) +
  xlab("Imputation") +
  ylab("OR, Condom Use") +
  theme

cffullhivfig

```

<br>

###### **Figure 16. Effect of bridgewidth (Odds Ratios, OR) on "Always" using a condom in relationship, stratified by gender. **

<br>

```{r cffull_bw_fig, echo = FALSE, warning = FALSE}
ticks <- c(0.5, 1.0, 2.0, 4.0, 8.0)

cffullbwfig <- cffullmodcoef %>%
  filter(term == "bridgewidth") %>%
  ggplot(aes(x = .imp, ratio)) +
   geom_hline(yintercept = 1, 
             color = "blue") +
  geom_point() +
  geom_pointrange(aes(ymax = rupr,
                      ymin = rlwr)) +
  facet_grid(sex ~ .) +
  # scale_y_log10(breaks = ticks) +
  xlab("Imputation") +
  ylab("OR, Condom Use") +
  theme

cffullbwfig

```


```{r cf_age_fig, include = FALSE, warning = FALSE}

# cfagefig <- cfmodpredage %>%
#   ggplot(aes(x = age, y = pred, group = .imp)) +
#   geom_line() +
#   facet_grid(. ~ sex) +
#   xlab("Age") +
#   ylab("Probability") +
#   theme
# 
# cfagefig

```

<br>

###### **Figure 17. Predicted probabilities of "Always" using a condom in a relationship for different ages of participant, stratified by gender.**

<br>

```{r cffull_age_fig, echo = FALSE, warning = FALSE}

cffullagefig <- cffullmodpredage %>%
  ggplot(aes(x = age, y = pred, group = .imp)) +
  geom_line() +
  facet_grid(. ~ sex) +
  xlab("Age") +
  ylab("Probability, Condom Use") +
  theme

cffullagefig

```

<br>

### **ARE LARGE BRIDGEWIDTHS ASSOCIATED WITH HIGHER SEX FREQUENCY IN RELATIONSHIPS?** 

<br>

I regressed sex frequency on bridgewidth. Sex frequency is a relationship-level variable that represents the average number of times a participant had sex per week with that partner. I used generalized additive mixed models with a poisson outcome and random intercept for participant. The relationship was the unit of observation and only relationships from participants reporting more than one relationship in the previous year were included. Models were applied to different imputed datasets and stratified by gender. All models adjust for age(smooth term) and race. Bridgewidth was treated as a continuous linear term because exploration using GAMS indicated it should be. 

<br>

###### **Figure 18. Distribution of average number of times sex occurred per week in relationships, stratified by gender and imputation dataset**

<br>

```{r sf_fig, echo = FALSE, warning = FALSE}

sffig <- impsexsb %>%
  unnest() %>%
  ggplot(aes(x = relsf, group = .imp)) +
  geom_density() +
  facet_grid(. ~ sex) +
  theme

sffig

```


```{r sf_hiv_fig, include = FALSE, warning = FALSE}

# sfhivfig <- sfmodcoef %>%
#   filter(term == "hivPositive") %>%
#   ggplot(aes(x = .imp, ratio)) +
#    geom_hline(yintercept = 1, 
#              color = "blue") +
#   geom_point() +
#   geom_pointrange(aes(ymax = rupr,
#                       ymin = rlwr)) +
#   facet_grid(sex ~ .) +
#   xlab("Imputation") +
#   ylab("IRR, Sex Frequency") +
#   theme
# 
# sfhivfig

```

<br>

###### **Figure 19. Effect of bridgewidth (Incidence Rate Ratios, IRRs) on average number of times sex occurred per week in the relationship, stratified by gender.**

<br>

```{r sf_bw_fig, echo = FALSE, warning = FALSE}

sfbwfig <- sfbwmodcoef %>%
  filter(term == "bridgewidth") %>%
  ggplot(aes(x = .imp, ratio)) +
   geom_hline(yintercept = 1, 
             color = "blue") +
  geom_point() +
  geom_pointrange(aes(ymax = rupr,
                      ymin = rlwr)) +
  facet_grid(sex ~ .) +
  xlab("Imputation") +
  ylab("IRR, Sex Frequency") +
  theme

sfbwfig

```

<br>

###### **Figure 20. Predicted average number of times sex occurred per week in a relationship for different ages of participant, stratified by gender.**

<br>

```{r sfbw_age_fig, echo = FALSE, warning = FALSE}

sfbwagefig <- sfbwmodpredage %>%
  ggplot(aes(x = age, y = pred, group = .imp)) +
  geom_line() +
  facet_grid(. ~ sex) +
  xlab("Age") +
  ylab("Predicted average number of times sex occurred per week") +
  theme

sfbwagefig

```

<br>

The following plots, visualize models where we are interested in the effect of whether the HIV status of a participant was associated with sex frequency in relationships. In these models HIV was our exposure of interest, and bridgewidth a hypothesized mediator. Again these were adjusted for age(smooth term) and race.

<br>

###### **Figure 21. Effect of HIV (Incidence Rate Ratios, IRR) on average number of times sex occurred per week in the relationship, stratified by gender.**

<br>

```{r sffull_hiv_fig, echo = FALSE, warning = FALSE}

sffullhivfig <- sffullmodcoef %>%
  filter(term == "hivPositive") %>%
  ggplot(aes(x = .imp, ratio)) +
   geom_hline(yintercept = 1, 
             color = "blue") +
  geom_point() +
  geom_pointrange(aes(ymax = rupr,
                      ymin = rlwr)) +
  facet_grid(sex ~ .) +
  xlab("Imputation") +
  ylab("IRR, Sex Frequency") +
  theme

sffullhivfig

```

<br>

###### **Figure 22. Effect of bridgewidth (Incidence Rate Ratios, IRR) on average number of times sex occurred per week in the relationship, stratified by gender.**

<br>

```{r sffull_bw_fig, echo = FALSE, warning = FALSE}

sffullbwfig <- sffullmodcoef %>%
  filter(term == "bridgewidth") %>%
  ggplot(aes(x = .imp, ratio)) +
   geom_hline(yintercept = 1, 
             color = "blue") +
  geom_point() +
  geom_pointrange(aes(ymax = rupr,
                      ymin = rlwr)) +
  facet_grid(sex ~ .) +
  xlab("Imputation") +
  ylab("IRR, Sex Frequency") +
  theme

sffullbwfig

```


```{r sf_age_fig, include = FALSE, warning = FALSE}

# sfagefig <- sfmodpredage %>%
#   ggplot(aes(x = age, y = pred, group = .imp)) +
#   geom_line() +
#   facet_grid(. ~ sex) +
#   xlab("Age") +
#   ylab("Predicted average number of times sex occurred per week") +
#   theme
# 
# sfagefig

```


<br>

###### **Figure 23. Predicted average number of times sex occurred per week in a relationship for different ages of participant, stratified by gender.**

<br>

```{r sffull_age_fig, echo = FALSE, warning = FALSE}

sffullagefig <- sffullmodpredage %>%
  ggplot(aes(x = age, y = pred, group = .imp)) +
  geom_line() +
  facet_grid(. ~ sex) +
  xlab("Age") +
  ylab("Predicted average number of times sex occurred per week") +
  theme

sffullagefig

```


```{r close, include = FALSE, warning = FALSE}
# ====================================================
# Detach libraries and remove objects from environment
# ====================================================
Vectorize(detach)(name = paste0("package:", c("tidyverse", "mice", "gamm4",
                                              "mgcv", "modelr", "broom", "nlme", 
                                              "mediation", "MASS", "magrittr")), 
                  unload = TRUE, 
                  character.only = TRUE)

rm(list=ls())

```

